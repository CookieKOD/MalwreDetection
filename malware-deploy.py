
import streamlit as st
import joblib
import pefile
import pandas as pd
import tensorflow as tf
import os
import time
import warnings
from sklearn.exceptions import InconsistentVersionWarning

# Charger le modèle sauvegardé au format .h5
model = tf.keras.models.load_model('malware-detection-model.h5')


# model = joblib.load('best_decision_tree_model_joblib.joblib')
# warnings.filterwarnings("ignore", category=InconsistentVersionWarning)

# Fonction pour extraire les caractéristiques d'un fichier .exe
def extract_features(file_path):
    try:
        pe = pefile.PE(file_path)
        pe.close()
        features = {
            "AddressOfEntryPoint": pe.OPTIONAL_HEADER.AddressOfEntryPoint,
            "MajorLinkerVersion": pe.OPTIONAL_HEADER.MajorLinkerVersion,
            "MajorImageVersion": pe.OPTIONAL_HEADER.MajorImageVersion,
            "MajorOperatingSystemVersion": pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
            "DllCharacteristics": pe.OPTIONAL_HEADER.DllCharacteristics,
            "SizeOfStackReserve": pe.OPTIONAL_HEADER.SizeOfStackReserve,
            "NumberOfSections": len(pe.sections),
            # Calculer le ResourceSize uniquement si les ressources existent
            "ResourceSize": sum([entry.DataSize for entry in pe.DIRECTORY_ENTRY_RESOURCE.entries if hasattr(entry, 'DataSize')]) 
            if hasattr(pe, "DIRECTORY_ENTRY_RESOURCE") else 0
            # "ResourceSize": sum([entry.DataSize for entry in pe.DIRECTORY_ENTRY_RESOURCE.entries]) if hasattr(pe, "DIRECTORY_ENTRY_RESOURCE") else 0
        }
        return pd.DataFrame([features])
    except Exception as e:
        st.error(f"Erreur lors de l'extraction des caractéristiques : {e}")
        return None

# Interface utilisateur Streamlit
st.title("Application de Détection de Malware ")
st.image("./images/IMG_Projects_Detecting-Malware_Bigstock.jpg", width=700)  
st.write("Chargez un fichier `.exe` pour prédire s'il s'agit d'un malware ou non.")

# Upload de fichier
uploaded_file = st.file_uploader("Téléchargez un fichier .exe", type=["exe"])

if uploaded_file:
    temp_file_path = f"temp_{uploaded_file.name}"
    with open(temp_file_path, "wb") as f:
        f.write(uploaded_file.getbuffer())

    # Extraire les caractéristiques
    features = extract_features(temp_file_path)

    if features is not None:

        # Assurez-vous que les colonnes sont présentes lors de la prédiction
        feature_names = ["AddressOfEntryPoint", "MajorLinkerVersion", "MajorImageVersion", 
                         "MajorOperatingSystemVersion", "DllCharacteristics", "SizeOfStackReserve", 
                         "NumberOfSections", "ResourceSize"]

        
        # features = features[feature_names]  # Sélectionner les bonnes colonnes

        features_values = features.values  # Convertir les données en tableau numpy sans noms de colonnes
        prediction = model.predict(features_values)
         # Convertir la prédiction en classe binaire
        predicted_class = (prediction[0] > 0.5).astype(int)  # Utiliser un seuil de 0.5 pour la classification binaire

        # Prédiction avec le modèle .h5
        # prediction = model.predict(features)
        st.subheader("Résultat")
        result = " un Malware !" if predicted_class == 1 else "Légitime, sans danger"

        st.write("Caractéristiques extraites après  : ", features)
        

        # Afficher le résultat
        st.subheader("Résultat")
        st.write(f"Le fichier est : **{result}**")

    # supprimer le fichier temporaire
    
    try:
        os.remove(temp_file_path)
    except PermissionError:
        time.sleep(1)  # Attendre une seconde avant de réessayer
        try:
            os.remove(temp_file_path)
        except Exception as e:
            st.error(f"Impossible de supprimer le fichier temporaire : {e}")


