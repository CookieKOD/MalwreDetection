import streamlit as st
import joblib
import pefile
import pandas as pd
import tensorflow as tf
import os
import time
import warnings
from sklearn.exceptions import InconsistentVersionWarning

# Charger le modèle sauvegardé au format .h5
model = tf.keras.models.load_model('malware-detection-model.h5')

# Fonction pour extraire les caractéristiques d'un fichier .exe
def extract_features(file_path):
    try:
        pe = pefile.PE(file_path)
        pe.close()
        features = {
            "AddressOfEntryPoint": pe.OPTIONAL_HEADER.AddressOfEntryPoint,
            "MajorLinkerVersion": pe.OPTIONAL_HEADER.MajorLinkerVersion,
            "MajorImageVersion": pe.OPTIONAL_HEADER.MajorImageVersion,
            "MajorOperatingSystemVersion": pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
            "DllCharacteristics": pe.OPTIONAL_HEADER.DllCharacteristics,
            "SizeOfStackReserve": pe.OPTIONAL_HEADER.SizeOfStackReserve,
            "NumberOfSections": len(pe.sections),
            "ResourceSize": sum([entry.DataSize for entry in pe.DIRECTORY_ENTRY_RESOURCE.entries if hasattr(entry, 'DataSize')]) 
            if hasattr(pe, "DIRECTORY_ENTRY_RESOURCE") else 0
        }
        return pd.DataFrame([features])
    except Exception as e:
        st.error(f"Erreur lors de l'extraction des caractéristiques : {e}")
        return None

# Interface utilisateur Streamlit
st.title("Détection de Malware avec un Modèle sauvegardé en .h5")
st.image("./images/IMG_Projects_Detecting-Malware_Bigstock.jpg", width=700)  
st.write("Chargez un fichier `.exe` pour prédire s'il s'agit d'un malware ou non.")

# Upload de fichier
uploaded_file = st.file_uploader("Téléchargez un fichier .exe", type=["exe"])

if uploaded_file:
    temp_file_path = f"temp_{uploaded_file.name}"
    with open(temp_file_path, "wb") as f:
        f.write(uploaded_file.getbuffer())

    # Extraire les caractéristiques
    features = extract_features(temp_file_path)

    if features is not None:
        # Assurez-vous que les colonnes sont présentes lors de la prédiction
        feature_names = ["AddressOfEntryPoint", "MajorLinkerVersion", "MajorImageVersion", 
                         "MajorOperatingSystemVersion", "DllCharacteristics", "SizeOfStackReserve", 
                         "NumberOfSections", "ResourceSize"]

        # Assurez-vous que les caractéristiques sont dans le bon format
        features_values = features[feature_names].values  # Convertir les données en tableau numpy sans noms de colonnes
        prediction = model.predict(features_values)

        # Debugging: Print the prediction shape and values
        st.write("Prediction shape:", prediction.shape)
        st.write("Prediction values:", prediction)

        # Convertir la prédiction en classe binaire
        predicted_class = (prediction[0] > 0.5).astype(int)  # Utiliser un seuil de 0.5 pour la classification binaire

        # Debugging: Print the predicted class
        st.write("Predicted class:", predicted_class)

        # Afficher le résultat
        st.subheader("Résultat")
        result = " un Malware !" if predicted_class == 1 else "Légitime, sans danger"
        st.write(f"Le fichier est : **{result}**")
        st.write("Caractéristiques extraites après  : ", features)

    # Supprimer le fichier temporaire
    try:
        os.remove(temp_file_path)
    except PermissionError:
        time.sleep(1)  # Attendre une seconde avant de réessayer
        try:
            os.remove(temp_file_path)
        except Exception as e:
            st.error(f"Impossible de supprimer le fichier temporaire : {e}")
